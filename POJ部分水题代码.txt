POJ1000
program p1000(Input,Output);
var
a,b:Integer;
begin
Readln(a,b);
Writeln(a+b);
end.
POJ1004
#include<iostream>
#include<iomanip>
using namespace std;
int main()
{
float a,b;
unsigned int c;
cin>>a;
b=a;
for(c=1;c<12;c++)
{
cin>>b;
a += b;
}
b=a/12;
cout<<"$"<<b<<fixed<<setprecision(2)<<endl;
return 0;
}
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
/**********************
author KINGRAIN@EECS_PKU
time May 16,2010
dorm
poj1013
称硬币
***********************/
#include <iostream>
#include <cstring>
using namespace std;
bool isLight(char);
bool isHeavy(char);
char Left[3][7]={0},Right[3][7]={0};
int result[3];
int main()
{
int n=0,k,j; char letter,resul[5];
cin >> n;
for (int i=0; i<n; i++)
{
for (j=0; j<3; j++)
{
cin >> Left[j] >> Right[j] >> resul;
if (strcmp(resul,"up")==0)
result[j] = 1;
if (strcmp(resul,"even")==0)
result[j] = 2;
if (strcmp(resul,"down")==0)
result[j] = 3;
}
for (letter='A'; letter<='L'; letter++)
{
if (isLight(letter))
{
cout << letter << " is the counterfeit coin and it is light.\n";
break;
}
else if (isHeavy(letter))
{
cout << letter << " is the counterfeit coin and it is heavy.\n";
break;
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
}
}
}
return 0;
}
bool isLight(char ch)
{
for (int i=0; i<3; i++)
{
switch(result[i])
{
case 1: if (strchr(Right[i],ch)==0)
return 0;
break;
case 2: if ((strchr(Right[i],ch)!=0)||(strchr(Left[i],ch)!=0))
return 0;
break;
case 3: if (strchr(Left[i],ch)==0)
return 0;
break;
}
}
return 1;
}
bool isHeavy(char ch)
{
for (int i=0; i<3; i++)
{
switch(result[i])
{
case 1: if (strchr(Left[i],ch)==0)
return 0;
break;
case 2: if ((strchr(Right[i],ch)!=0)||(strchr(Left[i],ch)!=0))
return 0;
break;
case 3: if (strchr(Right[i],ch)==0)
return 0;
break;
}
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
}
return 1;
}
/**********************
author KINGRAIN@EECS_PKU
time Mar.5,2010
dorm
poj1017
装箱问题
***********************/
#include <iostream>
#include <cstring>
using namespace std;
int main()
{
int b[6],i,nTotal=0,roomForBox2[4]={0,5,3,1},maxBox2=0,maxBox1_1=0;
do
{
for (i=0; i<6; i++)
cin >> b[i];
if ((b[0]==0)&&(b[1]==0)&&(b[2]==0)&&(b[3]==0)&&(b[4]==0)&&(b[5]==0))
break;
nTotal = b[5]+b[4]+b[3]+(b[2]+3)/4;
maxBox2 = 5*b[3]+roomForBox2[(b[2])%4];
if (b[1]>maxBox2)
nTotal += (b[1]-maxBox2+8)/9;
maxBox1_1 = nTotal*36-36*b[5]-25*b[4]-16*b[3]-9*b[2]-4*b[1];
if (b[0]>maxBox1_1)
nTotal += (b[0]-maxBox1_1+35)/36;
printf("%d\n",nTotal);
} while (1);
return 0;
}
/**********************
author KINGRAIN@EECS_PKU
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
time April 6,2010
dorm
poj1088
滑雪
***********************/
#include <iostream>
using namespace std;
const int SIZE = 110;
struct POINT
{
int height;
int x;
int y;
} position[SIZE*SIZE] = {0}; // 记录点的高度 坐标
int length[SIZE][SIZE]={0},height[SIZE][SIZE]={0};
int Mycompare(const void *,const void *);
int Max(int,int);
// 算法就是先找出凹点将其长度值为一
// 点length[i][j] = max{点length[i-1][j],点length[i+1][j],点length[i][j-1],点length[i][j+1]} 前提是这些点比它高……
int main()
{
int R=0,C=0,i=0,n=0,j=0,k=0,LONGEST = 0;
cin >> R >> C;
for (i=1; i<=R; i++)
for (j=1; j<=C; j++)
{
cin >> height[i][j];
position[k].height = height[i][j];
position[k].x = j;
position[k++].y = i;
}
qsort(position,k,sizeof(position[0]),Mycompare); // 将点按高度排列
for (j=0; j<=C; j++) // 将边沿置为最大值 在后面处理较为方便
height[0][j] = 999999, height[R+1][j] = 999999;
for (j=0; j<=R; j++)
height[j][0] = 999999, height[j][C+1] = 999999;
for (i=1; i<=R; i++)
for (j=1; j<=C; j++)
{
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
if ((height[i][j]<=height[i+1][j])&&(height[i][j]<=height[i-1][j]) // 对于凹点 长度就为
一
&&(height[i][j]<=height[i][1+j])&&(height[i][j]<=height[i][j-1]))
length[i][j] = 1;
}
for (i=0; i<k; i++)
{
if (length[position[i].y][position[i].x]==1)
continue;
else
{
if (height[position[i].y][position[i].x]>height[position[i].y][position[i].x+1])
length[position[i].y][position[i].x] = length[position[i].y][position[i].x+1] + 1;
if (height[position[i].y][position[i].x]>height[position[i].y][position[i].x-1])
length[position[i].y][position[i].x]
= Max(length[position[i].y][position[i].x],length[position[i].y][position[i].x-1]+1);
if (height[position[i].y][position[i].x]>height[position[i].y+1][position[i].x])
length[position[i].y][position[i].x]
= Max(length[position[i].y][position[i].x],length[position[i].y+1][position[i].x]+1);
if (height[position[i].y][position[i].x]>height[position[i].y-1][position[i].x])
length[position[i].y][position[i].x]
= Max(length[position[i].y][position[i].x],length[position[i].y-1][position[i].x]+1);
}
}
for (i=1; i<=R; i++)
for (j=1; j<=C; j++)
if (LONGEST<length[i][j])
LONGEST = length[i][j];
printf("%d\n",LONGEST);
return 0;
}
int Mycompare(const void *elem1,const void *elem2) // 按升序排列
{
POINT *ptr1,*ptr2;
ptr1 = (POINT *) elem1;
ptr2 = (POINT *) elem2;
return (ptr1->height-ptr2->height);
}
int Max(int a, int b)
{
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
if (a>=b)
return a;
else
return b;
}
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
/**********************
author KINGRAIN@EECS_PKU
time May 22,2010
computer room 159
poj1095
Trees made to order
***********************/
#include <iostream>
using namespace std;
void Creat_Tree(int );
int Trees_amount[25]={0};
int Tree_last_order[25]={0};
int wmain()
{
int i=0,j=0,m=0,n=0;
Trees_amount[0] = Trees_amount[1] = 1;
Trees_amount[2] = 2;
Tree_last_order[0] = 0;
Tree_last_order[1] = 1;
Tree_last_order[2] = 3;
for (i=3; i<25; i++)
{
for (j=0; j<i; j++)
Trees_amount[i] += Trees_amount[j]*Trees_amount[i-1-j];
Tree_last_order[i] = Tree_last_order[i-1] + Trees_amount[i];
}
while (cin>>n)
{
if (n==0)
break;
Creat_Tree(n);
cout << endl;
}
return 0;
}
void Creat_Tree(int n)
{
int i,j;
for (i=0; n>Tree_last_order[i]; i++); // 循环结束时 此棵树上共有 i 个节点
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
n -= Tree_last_order[i-1]; // 这是 i 个节点 的第n 棵树
for (j=0; j<i; j++) // 右树一共有i-1-j 个节点 左树一共有j 个节点
{
if (n<=Trees_amount[i-1-j]*Trees_amount[j])
break;
else
n -= Trees_amount[i-1-j]*Trees_amount[j];
}
if (j!=0)
{
cout << '(';
Creat_Tree((n-1)/Trees_amount[i-1-j]+1+Tree_last_order[j-1]);
cout << ')';
}
cout << 'X';
if ((i-1-j)!=0)
{
cout << '(';
Creat_Tree((n-1)%Trees_amount[i-j-1]+1+Tree_last_order[i-j-2]);
cout << ')';
}
}
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
/**********************
author KINGRAIN@EECS_PKU
time April 2,2010
classroom
poj1163
The Triangle
***********************/
#include <iostream>
using namespace std;
const int MAX = 110;
int highestSum[MAX][MAX] = {0},position[MAX][MAX]={0}; // high[] 记录最大值 ，position[]记录位置 存储的值
inline int Max(int, int);
int main()
{
int n=0,j=0,i=0;
cin >> n;
for (i=0; i<n; i++)
for (j=0; j<=i; j++)
cin >> position[i][j];
for (i=0; i<n; i++)
highestSum[n-1][i] = position[n-1][i]; // 初始化最底层的最大值
for (i=n-2; i>=0; i--)
for (j=0; j<=i; j++) // 递推关系式 当前的最大值等于上一
步的最大值加当前节点数值
highestSum[i][j] = Max(highestSum[i+1][j],highestSum[i+1][j+1]) + position[i][j];
printf("%d\n",highestSum[0][0]);
return 0;
}
inline int Max(int a, int b)
{
if (a>b)
return a;
else
return b;
}
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
/**********************
author KINGRAIN@EECS_PKU
time April 2,2010
computerroom
poj2815
城堡问题
***********************/
#include <iostream>
using namespace std;
int Move(int, int, bool);
const int M=55,N=55;
int CASTLE[M][N]={0},m=0,n=0,state[M][N]={0},Room=0;
int main()
{
int j=0,i=0,k=0,t=0,Max_area=0,area=0;
cin >> m >> n;
for (i=0; i<m; i++)
for (j=0; j<n; j++)
cin >> CASTLE[i][j];
for (i=0; i<m; i++)
for (j=0; j<n; j++) // 以每个位置为出发点，让假想的小人出发。如果走过这间房子很快就会退
出因此不会太浪费时间
{
area = Move(i,j,0);
if (area>Max_area)
Max_area = area;
}
printf("%d\n%d\n",Room,Max_area);
return 0;
}
int Move(int y, int x,bool flag) // 函数返回值是面积
{
// 假设有一个人从 (x,y) 的位置出发，在城堡里走动
if ((flag==0)&&(state[y][x]==0)) // flag==0 说明是直接从主函数进来的 state==0 说明这是一个新房间
Room++;
if ((y<0)||(x<0)||(y>=m)||(x>=n)) // 越界
return 0;
if (state[y][x]==1) // 标记为已经走过
return 0;
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
state[y][x] = 1;
switch (CASTLE[y][x])
{
// 一开始把case 0 忘记了 结果很惨 上机的时候 一个小时纠结在这上面了 只是因为 case 0
case 0: return Move(y,x+1,1)+Move(y-1,x,1)+Move(y+1,x,1)+Move(y,x-1,1)+1; break;
case 1: return Move(y,x+1,1)+Move(y-1,x,1)+Move(y+1,x,1)+1; break; // w return break????
case 2: return Move(y,x+1,1)+Move(y+1,x,1)+Move(y,x-1,1)+1; break; // n
case 3: return Move(y,x+1,1)+Move(y+1,x,1)+1; break; // wn
case 4: return Move(y,x-1,1)+Move(y-1,x,1)+Move(y+1,x,1)+1; break; // e
case 5: return Move(y+1,x,1)+Move(y-1,x,1)+1; break; // we
case 6: return Move(y,x-1,1)+Move(y+1,x,1)+1; break; // ne
case 7: return Move(y+1,x,1)+1; break; // nwe
case 8: return Move(y,x+1,1)+Move(y-1,x,1)+Move(y,x-1,1)+1; break; // s
case 9: return Move(y,x+1,1)+Move(y-1,x,1)+1; break; // ws
case 10: return Move(y,x+1,1)+Move(y,x-1,1)+1; break; // ns
case 11: return Move(y,x+1,1)+1; break; // nws 字母代表墙的方向，
没有墙的方向是可以让人走的
case 12: return Move(y,x-1,1)+Move(y-1,x,1)+1; break; // es
case 13: return Move(y-1,x,1)+1; break; //wes
case 14: return Move(y,x-1,1)+1; break; // esn
case 15: return 1; break;
}
}
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
/**********************
author KINGRAIN@EECS_PKU
time Mar.28,2010
computer room
poj1166
the clocks
***********************/
#include <iostream>
#include <memory.h>
using namespace std;
int method[10] = {0},move[10]={0},state[10]={0},start[10]={0},
// 用查表法 move
make[10][5]={0,0,0,0,0,1,2,4,5,0,1,2,3,0,0,2,3,5,6,0,1,4,7,0,0,2,4,5,6,8,3,6,9,0,0,4,5,7,8,0,7,8,9,0,0,5,6,8,9,0};
int main()
{
// 解题思路 先枚聚 前四个 然后后面的方法可以唯一确定 1234-5B-6C-7D-8G-9I
int i=0,j=0,k=0,n=0; bool flag=0; int step=0,minStep=9999;
for (i=1; i<10; i++)
cin >> start[i];
for (move[1]=0; move[1]<4; move[1]++)
{
memcpy(state,start,sizeof(start));
state[1] += move[1], state[2] += move[1], state[4] += move[1], state[5] += move[1];
for (move[2]=0; move[2]<4; move[2]++)
{
state[1] += move[2], state[2] += move[2], state[3] += move[2];
for (move[3]=0; move[3]<4; move[3]++)
{
state[2] += move[3], state[3] += move[3], state[5] += move[3], state[6] += move[3];
for (move[4]=0; move[4]<4; move[4]++)
{
for (j=0; j<3; j++)
state[j*3+1] += move[4];
// 以下均为必然事件
move[5] = (4 - (state[2]%4))%4;
for (j=0; j<5; j++)
state[make[5][j]] += move[5];
move[6] = (4 - (state[3]%4))%4;
for (j=0; j<5; j++)
state[make[6][j]] += move[6];
move[7] = (4 - (state[4]%4))%4;
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
for (j=0; j<5; j++)
state[make[7][j]] += move[7];
move[8] = (4 - (state[7]%4))%4;
for (j=0; j<5; j++)
state[make[8][j]] += move[8];
move[9] = (4 - (state[9]%4))%4;
for (j=0; j<5; j++)
state[make[9][j]] += move[9];
for (j=1,flag=1; j<=9; j++)
if (state[j]%4!=0)
{
flag = 0;
break;
}
if (flag==1)
{
for (j=1,step=0; j<=9; j++)
step += move[j];
if (step<minStep) // 说明是最短步数
{
minStep = step; // 设置最短步数
memcpy(method,move,sizeof(move));
}
}
for (j=0; j<5; j++)
state[make[5][j]] -= move[5];
for (j=0; j<5; j++)
state[make[6][j]] -= move[6];
for (j=0; j<5; j++)
state[make[7][j]] -= move[7];
for (j=0; j<5; j++)
state[make[8][j]] -= move[8];
for (j=0; j<5; j++)
state[make[9][j]] -= move[9];
for (j=0; j<5; j++)
state[make[4][j]] -= move[4];
}
for (j=0; j<5; j++)
state[make[3][j]] -= move[3]; // 相当于回溯 退回到刚才的状态
}
for (j=0; j<5; j++)
state[make[2][j]] -= move[2];
}
}
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
for (j=1; j<=9; j++)
for (i=0; i<method[j]; i++)
cout << j << ' ';
cout << endl;
return 0;
}
/* POJ1218
drunk jailer
time Oct.10,2009
address computer room
*/
#include<iostream>
using namespace std;
int main()
{
bool a[102]; int i,k,n,m=0;
cin>>n;
for(i=1;i<=n;i++)
{
a[i]=1;
}
for(k=1;k<=n;k++)
{
for(i=1;i<=n;i++)
{
if(i%k==0)
a[i]=!a[i];
}
}
for(i=1;i<=n;i++)
{
if(a[i]==0)
m++;
}
cout<<m<<endl;
return 0;
}
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
/**********************
author KINGRAIN@EECS_PKU
time Jan.2,2010
address computer room 184
poj2975
Caser 密码
***********************/
#include<iostream>
#include<iomanip>
#include<cmath>
#include<memory>
using namespace std;
int main()
{
char text[120][210],temp[300];
int i=0,j,n;
do
{
cin.getline(temp,300);
if (strcmp(temp,"START")==0)
{
cin.getline(text[i++],210);
}
} while (strcmp(temp,"ENDOFINPUT")!=0);
n=i;
for (i=0; i<n; i++)
{
for (j=0; j<strlen(text[i]); j++)
{
if ((text[i][j]>='A')&&(text[i][j]<='E'))
text[i][j] += 21;
else if
((text[i][j]>'E')&&(text[i][j]<='Z'))
text[i][j] -= 5;
}
cout << text[i] << '\n';
}
return 0;
}
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
//POJ1321
#include <iostream>
#include <cmath>
#include <cstring>
using namespace std;
int n,k,kind[100]={0},ttt; // ttt 为第几组数据
char pan[8][9];
bool heng[8], shu[8];
void make_it(int,int); //表示行 , chess num
int main()
{
do
{
cin >> n >> k;
if ((n<0)||(k<0))
break;
for (int i=0; i<n; i++)
cin >> pan[i];
//for (int jj=0; jj<n; jj++)
make_it(0,k);
ttt++;
} while (1);
for (int i=0; i<ttt; i++)
cout << kind[i] << endl;
return 0;
}
void make_it(int num,int chess)
{
for (int j=0; j<n; j++)
{
if ((pan[num][j]=='#')&&(heng[num]==0)&&(shu[j]==0))
{
heng[num]=1;
shu[j]=1;
if (chess==1)
{
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
kind[ttt]++;
heng[num]=0;
shu[j]=0;
continue;
}
else if (num<n-1)
make_it(num+1,chess-1);
heng[num]=0;
shu[j]=0;
}
}
if ((num<n-1)) // 表示在这一行chess 不妨棋子
make_it(num+1,chess);
}
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
/**********************
author KINGRAIN@EECS_PKU
time Aug.1,2010
home
poj1338
Ugly Numbers
************************/
#include <iostream>
#include <set>
using namespace std;
set<unsigned int> ugly;
int wmain()
{
int amount = 1, n, order;
ugly.insert(1);
pair<set<unsigned int>::iterator,bool> ptr;
set<unsigned int>::iterator i=ugly.begin();
for (i=ugly.begin(); amount<1750; i++)
{
ptr = ugly.insert(2 * (*i));
if (2 * (*i)==4849664)
cout.put(7);
if ((*i)==4849664)
cout.put(7), cout.put(7);
if (ptr.second==1)
amount++;
ptr = ugly.insert(3 * (*i));
if (ptr.second==1)
amount++;
ptr = ugly.insert(5 * (*i));
if (ptr.second==1)
amount++;
}
while (cin >> n)
{
if (n==0)
break;
order = 1;
for (i=ugly.begin(); order<n; i++,order++);
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
cout << (*i) << endl;
}
return 0;
}
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
/* POJ1519 & POJ2764
功能 数根
作者 KINGRAIN@EECS_PKU
time Oct.17,2009
address computer room
*/
#include<iostream>
using namespace std;
int main()
{
short int root,n,b; char num[1000]; bool g=0;
do
{ unsigned short int i=0;
while(1)
{
num[i]=getchar(); i++;
if((num[0]=='0'))
{ return 0;}
if(num[i-1]=='\n') break;
}
if(g==1) break;
n=i-2; //一共n 位数
root=0;
for(i=0;i<=n;i++)
{ root=root+num[i]-48; } // 全变成数字了
b=0;
do
{
b=root%10+b;
root=root/10;
}while((root>=1));
if(b<10) root=b;
else { root=b; b=b%10; root=root/10+b;}
cout<<root<<endl;
}while(1);
return 0;
}
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
/**********************
author KINGRAIN@EECS_PKU
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
time Feb.8,2010
home
poj1657
棋盘上的距离 Distance on Chessboard
***********************/
#include<iostream>
#include<cmath>
#include<cstring>
using namespace std;
int main()
{
int n,i;char current[3],goal[3];
cin >> n;
for (i=0; i<n; i++)
{
cin >> current >> goal;
if ((current[0]==goal[0])&&(current[1]==goal[1]))
printf("0 0 0 0\n");
else
{
// King
if (fabs(1.0*(current[0]-goal[0]))>=fabs(1.0*(current[1]-goal[1])))
{
if (current[0]>goal[0])
cout << current[0]-goal[0] << ' ';
else
cout << goal[0]-current[0] << ' ';
}
else
{
if (current[1]>goal[1])
cout << current[1]-goal[1] << ' ';
else
cout << goal[1]-current[1] << ' ';
}
// Queen
if ((current[0]==goal[0])||(current[1]==goal[1])||((current[1]+current[0])==(goal[1]+goal[0]))
||((current[0]-current[1])==(goal[0]-goal[1]))||((current[1]-current[0])==(goal[0]-goal[1])))
cout << "1 ";
else
cout << "2 ";
// Castle
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
if ((current[0]==goal[0])||(current[1]==goal[1]))
printf("1 ");
else
printf("2 ");
// Bishop
if ((current[0]+current[1])%2 != (goal[1]+goal[0])%2)
printf("Inf\n");
else if (((current[1]+current[0])==(goal[1]+goal[0]))
||((current[0]-current[1])==(goal[0]-goal[1]))
||((current[1]-current[0])==(goal[0]-goal[1])))
printf("1\n");
else
printf("2\n");
}
}
return 0;
}
// POJ1658
#include<iostream>
using namespace std;
int main()
{
int a,b,c,d,n,i;
cin>>n;
for(i=1;i<=n;i++)
{
cin>>a>>b>>c>>d;
if((d-c)==(c-b))
{
cout<<a<<" "<<b<<" "<<c<<" "<<d<<" "<<d*2-c<<endl;
}
else //若不是等差数列必然就是等比数列
{
cout<<a<<" "<<b<<" "<<c<<" "<<d<<" "<<d*d/c<<endl;
}
}
return 0;
}
/**********************
author KINGRAIN@EECS_PKU
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
time May 21,2010
dorm
poj1661
帮助Jimmy
***********************/
#include <iostream>
using namespace std;
const int AMOUNT = 1100;
struct POSITION
{
int x1, x2, h, left_time, right_time;
}position[AMOUNT];
int MAX = 0, N;
int Find_min(int, int, int);
inline int Mycompare(const void *, const void *);
inline int Min(int, int);
int main()
{
int t,X,Y,i,j;
cin >> t;
for (j=0; j<t; j++)
{
cin >> N >> X >> Y >> MAX;
for (i=0; i<N; i++)
{
cin >> position[i].x1 >> position[i].x2 >> position[i].h;
position[i].left_time = position[i].right_time = -1;
}
position[i].h = 0, position[i].left_time = position[i].right_time = 0, position[i].x1 = -9999999,
position[i].x2 = 9999999;
position[i+1].h = Y, position[i+1].x1 = position[i+1].x2 = X, position[i+1].left_time =
position[1+i].right_time = -1;
qsort(position,N+2,sizeof(position[0]),Mycompare);
;
cout << Find_min(X,Y,-1) << endl;
}
return 0;
}
int Find_min(int x, int h, int j)
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
{
int h0=0,i=0;
for (i=j+1; i<=N+1; i++)
{
if ((position[i].x1<=x)&&(position[i].x2>=x))
{
if (h-position[i].h>MAX)
return 999999;
if (position[i].h==0)
{
return h;
}
h0 = h - position[i].h;
break;
}
} // 注意注意！ 落到边上 算是落到平台
上！！！！！
if (position[i].left_time==-1)
position[i].left_time = Find_min(position[i].x1,position[i].h,i);
if (position[i].right_time==-1)
position[i].right_time = Find_min(position[i].x2,position[i].h,i);
int k1,k2;
k1 = x - position[i].x1 + position[i].left_time;
k2 = position[i].x2 - x + position[i].right_time;
return Min(k1,k2) + h0;
}
inline int Mycompare(const void *ele1, const void *ele2)
{
POSITION *p1 = (POSITION *)ele1;
POSITION *p2 = (POSITION *)ele2;
if ((p1->h) >= (p2->h))
return -1;
else
return 1;
}
inline int Min(int a,int b)
{
if (a>b)
{
return b;
}
else
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
{
return a;
}
}
/**********************
author KINGRAIN@EECS_PKU
time Mar.24,2010
dorm 232
poj1664
放苹果
***********************/
#include <iostream>
using namespace std;
int kinds(int apple, int dishes);
int main()
{
int n=0,k=0,j=0,apple=0,dishes=0;
cin >> n;
for (int i=0; i<n; i++)
{
cin >> apple >> dishes;
cout << kinds(apple,dishes) << endl;
}
return 0;
}
int kinds(int apple, int dishes)
{
if ((apple==0)||(dishes==1))
return 1;
if (apple<dishes)
return (kinds(apple,apple));
else
return (kinds(apple-dishes,dishes)+kinds(apple,dishes-1));
}
/**********************
author KINGRAIN@EECS_PKU
time Mar.28,2010
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
computer room
poj1681
painter's problem
***********************/
#include <iostream>
#include <cmath>
#include <memory.h>
using namespace std;
const int SIZE = 17;
bool brick[SIZE][SIZE]={0},temp[SIZE][SIZE]={0};
void SetSwitch(int &, int &,int &);
int minStep=99999;
int main()
{
int i=0,j=0,k=0,x=0,y=0,n=0,t=0,num=0,size=0,step=0; // num 表示枚举次数 i 表示测试数据序号 t 表示测试数据
总数 j,k 是计数器 size 是正方形边长 x,y 是横纵坐标
bool flag=1; char ch;
cin >> t;
for (i=0; i<t; i++)
{
cin >> size;
for (j=0; j<size; j++)
for (k=0; k<size; k++)
{
cin >> ch;
if (ch=='y')
brick[j][k] = 1; // 用二进制表示砖的颜色 1 表示黄 0
表示白
else
brick[j][k] = 0;
}
minStep = 99999;
num = (int)pow(2.0,(double)size); // 设置枚举次数
for (j=0,step=0; j<num; j++,step=0)
{
memcpy(temp,brick,sizeof(brick)); // 将数据放入临时数组 可以随便改，
保持原始数据原样
SetSwitch(j,step,size); // 枚举第一行 其实可以不用开辟函数 直接用循
环也行
if (step>minStep) // 目标要找最小步数 如果已经大于最小步数就
没必要再找下去了
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
continue;
for (y=1; y<size && step<=minStep; y++) // 下一行开关的 目标 是关闭上一
行的灯
for (x=0; x<size && step<=minStep; x++)
{
if (temp[y-1][x]==0)
{
temp[y-1][x] = 1; // 下一
行怎么刷由上一行完全决定 与开灯问题如出一辙
temp[y][x] =! temp[y][x];
if (x>0)
temp[y][x-1] = !temp[y][x-1];
if (x<size-1)
temp[y][x+1] = !temp[y][x+1];
if (y<size-1)
temp[y+1][x] = !temp[y+1][x];
step++;
}
}
for (y=size-1,x=0,flag=1; x<size; x++) // 检测最后一行
if (temp[y][x]==0)
{
flag = 0;
break;
}
if ((flag==1)&&(step<=minStep))
minStep = step;
}
if (minStep==99999) // 粗略估计 如果能完成，步数不可能达到 99999 以此来判断是否可
以
printf("inf\n");
else
cout << minStep << endl;
}
return 0;
}
void SetSwitch(int & order, int & step, int & size) // 枚举第一行 其实可以不用开辟函数 直接用循环也行
{
for (int i=0; i<size; i++)
{
if (((order>>i)&1)==1)
{
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
step++;
temp[0][i] = !temp[0][i];
if (i>0)
temp[0][i-1] = !temp[0][i-1];
if (i<size-1)
temp[0][i+1] = !temp[0][i+1];
if (size>1)
temp[1][i] = !temp[1][i];
if (step>minStep)
return ;
}
}
}
/**********************
author KINGRAIN@EECS_PKU
time May 21,2010
dorm
poj1833
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
排列
***********************/
#include <iostream>
using namespace std;
inline int Mycompare(const void*, const void *);
int Array[1500]={0};
int wmain()
{
int n,i,j,MAX,l,temp,k=0,N=0;
cin >> N;
for (j=0; j<N; j++)
{
cin >> n >> k;
for (i=0; i<n; i++)
cin >> Array[i];
for (k; k>0; k--)
{
for (i=n-1,MAX=Array[n-1]; i!=-1; i--)
{
if (MAX<=Array[i])
{
MAX = Array[i];
continue;
}
break;
}
if (i!=-1)
{
for (l=n-1; Array[i]>Array[l]; l--);
temp = Array[i];
Array[i] = Array[l];
Array[l] = temp;
qsort(Array+i+1,n-i-1,sizeof(int),Mycompare);
}
else
for (i=0; i<n; i++)
Array[i] = i+1;
}
for (i=0; i<n; i++)
cout << Array[i] << ' ';
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
cout << endl;
}
return 0;
}
inline int Mycompare(const void* ele1, const void *ele2)
{
int *ptr1 = (int*)ele1, *ptr2 = (int*)ele2;
return -(*ptr2-*ptr1);
}
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
/**********************
author KINGRAIN@EECS_PKU
time Mar.24,2010
dorm 232
poj1979&2816
红与黑
***********************/
#include <iostream>
using namespace std;
char floor[30][30]={0};
int W=0,H=0;
int move(int , int);
int main()
{
int i=0,j=0,x=0,y=0,n=0;
do
{
cin >> W >> H;
if (W==0)
break;
for (i=0,x=0,y=0; i<H; i++)
for (j=0; j<W; j++)
{
cin >> floor[i][j];
if (floor[i][j]=='@')
{
x=j; y=i;
}
}
n= move(x,y);
cout << n << endl;
} while(1);
return 0;
}
int move(int x, int y)
{
if ((x<0)||(x>=W)||(y<0)||(y>=H)||(floor[y][x]=='#'))
return 0;
floor[y][x] = '#';
return (1+move(x-1,y)+move(x+1,y)+move(x,y-1)+move(x,y+1));
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
}
/**********************
author KINGRAIN@EECS_PKU
time Aug.1,2010
home
poj2386
Lake Counting
***********************/
#include <iostream>
#include <cmath>
#include <memory.h>
using namespace std;
const int SIZE = 150;
char MAP[SIZE][SIZE]={0};
int X=0, Y=0; // X is wedth. Y is heigth
int amount=0; // There is amount lakes.
void Find(int ,int );
int wmain()
{
cin >> Y >> X;
for (int j=0; j<Y; j++)
for (int i=0; i<X; i++)
cin >> MAP[j][i];
for (int j=0; j<Y; j++)
for (int i=0; i<X; i++)
if (MAP[j][i]=='W')
{
amount++;
Find(j,i);
}
cout << amount << endl;
return 0;
}
void Find(int y,int x)
{
if (MAP[y][x]=='.')
return;
MAP[y][x] = '.';
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
if (y>0)
{
if ((x>0)&&(MAP[y-1][x-1]=='W'))
Find(y-1,x-1);
if (MAP[y-1][x]=='W')
Find(y-1,x);
if ((x<X-1)&&(MAP[y-1][x+1]=='W'))
Find(y-1,x+1);
}
if ((x>0)&&(MAP[y][x-1]=='W'))
Find(y,x-1);
if ((x<X-1)&&(MAP[y][x+1]=='W'))
Find(y,x+1);
if (y<Y-1)
{
if ((x>0)&&(MAP[y+1][x-1]=='W'))
Find(y+1,x-1);
if (MAP[y+1][x]=='W')
Find(y+1,x);
if ((x<X-1)&&(MAP[y+1][x+1]=='W'))
Find(y+1,x+1);
}
}
// POJ2675
#include<iostream>
#include<iomanip>
using namespace std;
int main()
{
int i,k; double x; int a,b,c,d,e,f,g,h,j,l;
cin>>k;
for(i=1;i<=k;i++)
{
cin>>a>>b>>c>>d>>e>>f>>g>>h>>j>>l;
x=a*28.9+b*32.7+c*45.6+d*78+e*35+f*86.2+g*27.8+h*43+j*56+l*65;
cout<<fixed<<setprecision(2)<<x<<endl;
}
return 0;
}
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
// poj2676
#include<iostream>
using namespace std;
int main()
{
unsigned int k,i,a,b,c,m;
cin>>k;
a=0;
b=0;
c=0;
for(i=1;i<=k;i++)
{
cin>>m;
if(m==1)
{a += 1;}
if(m==5)
{b += 1;}
if(m==10)
{c += 1;}
}
cout<<a<<endl;
cout<<b<<endl;
cout<<c<<endl;
return 0;
}
/**********************
author KINGRAIN@EECS_PKU
time Jan.23,2010
home
poj2677
肿瘤检测
***********************/
#include<iostream>
using namespace std;
int main()
{
int knub[101][101], n, i, j, area=0, length=0;
cin >> n;
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
for (i=0; i<n*n; i++)
{
cin >> knub[i/n][i%n];
if (knub[i/n][i%n]<=50)
area++;
}
for (i=0; i<n; i++)
{
for (j=0; j<n; j++)
{
if (knub[i][j]<=50)
{
if ((i==0)||(j==0)||(i==n-1)||(j==n-1)) // 矩阵的边界
点
length++;
else if
((knub[i-1][j]>50)||(knub[i+1][j]>50)||(knub[i][j+1]>50)||(knub[i][j-1]>50))
length++;
}
}
}
cout << area << ' ' << length << endl;
return 0;
}
//POJ2679
#include<iostream>
using namespace std;
int main()
{
unsigned int k,a,b;
cin>>k;
b=0;
for(a=1;a<=k;a++)
{
b=b+a*a*a;
}
cout<<b<<endl;;
return 0;
}
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
//2680
//address computerroom
//time Jan.2,2010
//function 化验诊断
//WANGYU
#include<iostream>
#include<cstring>
using namespace std;
int main()
{
int n, i=0,state;
double WBC[200],RBC[200],HGB[200],HCT[200],PLT[200];
char gender[200][10],nn[4];
cin.getline(nn,4);
n=atoi(nn);
for (i=0; i<n; i++)
{
cin >> gender[i] >> WBC[i] >> RBC[i] >> HGB[i] >> HCT[i] >> PLT[i];
}
for (i=0; i<n; i++)
{
state=0;
if (strcmp(gender[i],"male")==0)
{
if ((WBC[i]<4)||(WBC[i]>10))
state++;
if ((RBC[i]<3.5)||(RBC[i]>5.5))
state++;
if ((HGB[i]<120)||(HGB[i]>160))
state++;
if ((HCT[i]<42)||(HCT[i]>48))
state++;
if ((PLT[i]<100)||(PLT[i]>300))
state++;
}
if (strcmp(gender[i],"female")==0)
{
if ((WBC[i]<4)||(WBC[i]>10))
state++;
if ((RBC[i]<3.5)||(RBC[i]>5.5))
state++;
if ((HGB[i]<110)||(HGB[i]>150))
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
state++;
if ((HCT[i]<36)||(HCT[i]>40))
state++;
if ((PLT[i]<100)||(PLT[i]>300))
state++;
}
if (state==0)
cout << "normal\n";
else
cout << state << '\n';
}
return 0;
}
/**********************
循环移动
poj2682
author KINGRAIN@EECS_PKU
time Dec.9,2009
address computer room 184
***********************/
#include<iostream>
void move(short int a[], short int, short int &n);
using namespace std;
short int num; bool flag=1;
int main()
{
short int array[100]={0}, *p=NULL, *q=NULL, n; bool flag=1;
cin >> n >> num;
for (int i=0; i<n; i++)
{
cin >> array[i];
}
move(array, 0, n);
for (int i=0; i<n; i++)
cout << array[i] << ' ';
cout << endl;
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
return 0;
}
void move(short int array[], short int m, short int &n)
{
short int *p=NULL,temp;
if (m<num)
{
p=array+n-num+m;
temp=*p;
m++; move(array, m, n);
}
if (flag==1)
{
flag=0;
for (p=array+n-1; p>=array+num; p--)
*p = *(p-num);
}
p=array; *(p+m-1)=temp;
}
//POJ2683
#include<iostream>
#include<iomanip>
using namespace std;
int main()
{
int n,i;double d=0,a[9999],b[9999],c[9999];
cin>>n; a[0]=1; a[1]=2; b[0]=1; b[1]=1;
for(i=1;i<=n;i++)
{
a[i+1]=a[i]+a[i-1];
b[i+1]=b[i]+b[i-1];
c[i]=a[i]/b[i];
d=d+c[i];
}
cout<<fixed<<setprecision(4);
cout<<d<<endl;
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
return 0;
}
//POJ2684
#include<iostream>
using namespace std;
int main()
{
int a,i,n,b,c;
cin>>n; b=0; c=1;
while(c<=n)
{
a=1;
for(i=1;i<=c;i++)
{
a=a*i;
}
b=b+a;
c++;
}
cout<<b<<endl;
return 0;
}
//POJ2685
#include<iostream>
using namespace std;
int main()
{
unsigned int i,a,b,c,d;
for(i=100;i<1000;i++)
{
a=i%10;
b=i%100;
c=i-b;
b=b-a;
b=b/10;
c=c/100;
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
d=a*a*a+b*b*b+c*c*c;
if(i==d)
{
cout<<i<<endl;
}
}
return 0;
}
//2686 打印完数
#include<iostream>
using namespace std;
int main()
{
int a=0,n,i;
for(n=2;n<=1000;n++)
{ a=0;
for(i=1;i<n;i++)
{
if(n%i==0)
a=a+i;
}
if(a==n)
{ cout<<n<<" its factors are 1";
//if(n!=1)
{for(i=2;i<n;i++)
{
if(n%i==0)
{ cout<<","<<i;}
}
cout<<" "<<endl;
}
}
}
return 0;
}
/**********************
author KINGRAIN@EECS_PKU
time Jan.23,2010
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
home
poj2687
逆序存放数组
***********************/
#include<iostream>
using namespace std;
int main()
{
int array1[200], n, i;
cin >> n;
for (i=0; i<n; i++)
cin >> array1[i];
for (i=0; i<n; i++)
cout << array1[n-1-i] << ' ';
cout << endl;
return 0;
}
/**********************
author KINGRAIN@EECS_PKU
time Mar.5,2010
dorm
poj2691
打印极值点下标
***********************/
#include <iostream>
#include <cstring>
using namespace std;
int main()
{
int n,i,element[90],k,j;
scanf("%d",&n);
for (i=0; i<n; i++)
{
scanf("%d",&k);
for (j=0; j<k; j++)
scanf("%d",&element[j]);
if (element[0]!=element[1])
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
printf("0 ");
for (j=1; j<k-1; j++)
{
if (((element[j]>element[j-1])&&(element[j]>element[j+1]))
||((element[j]<element[j-1])&&(element[j]<element[j+1])))
printf("%d ",j);
}
if (element[k-1]!=element[k-2])
printf("%d",k-1);
cout << endl;
}
return 0;
}
/**********************
author KINGRAIN@EECS_PKU
time April 7,2010
dorm
poj2694
逆波兰表达式
***********************/
#include <iostream>
#include <cmath>
#include <iomanip>
using namespace std;
double exp();
int main()
{
cout << fixed << setprecision(6) << exp() << endl;
return 0;
}
double exp()
{
char ch=0; double n=0;
while ((ch = cin.peek())==' ') // 经验教训 cin.peek() 把空格也读入
cin.get();
switch (ch)
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
{
case '*': cin >> ch; return (exp()*exp());
case '/': cin >> ch; return (exp()/exp());
case '+': cin >> ch; return (exp()+exp());
case '-': cin >> ch; return (exp()-exp());
default : {
char num[15];
cin >> num;
n = atof(num);
}
return n;
}
}
/**********************
author KINGRAIN@EECS_PKU
time Jan.24,2010
home
poj2697
麦森数
***********************/
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cmath>
using namespace std;
int main()
{
int n, i; double a[500],b[500],x[500],x1[500],y[500],x2[500]={0};
cin >> n;
for (i=0; i<n; i++)
{
cin >> a[i] >> b[i];
x1[i] = -a[i];
x[i] = (x2[i]+x1[i])/2;
y[i] = x[i]*x[i]*x[i] + x[i] + a[i];
if (fabs(x1[i]-x2[i])<b[i])
continue;
while (fabs(y[i])>b[i])
{
if (fabs(x1[i]-x2[i])<b[i])
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
break;
if (y[i]>0)
x2[i]=x[i];
else
x1[i]=x[i];
x[i] = (x2[i]+x1[i])/2.0;
y[i] = x[i]*x[i]*x[i] + x[i] + a[i];
}
}
for (i=0; i<n; i++)
{
cout << fixed << setprecision(6) << x[i] << ' ';
if (fabs(y[i])<0.00000005)
cout << "0.000000\n";
else
cout << fixed << setprecision(6) << y[i] << '\n';
}
return 0;
}
/**********************
author KINGRAIN@EECS_PKU
time Feb.11,2010
home
poj2698
八皇后问题
***********************/
#include<iostream>
#include<cstring>
using namespace std;
bool latitude[8]={0},longitude[8]={0},diagonal1[15]={0},diagonal2[15]={0};
bool chessBoard[8][8]={0};
short int queens=8;
int j=0,k=0;
short int cASe=0;
void Check_Queen(short int);
int main()
{
Check_Queen(0);
cout << endl;
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
return 0;
}
void Check_Queen(short int line)
{
int i=0;
for (i=0; i<8; i++) // i 表示行
{
if
((latitude[i]==0)&&(longitude[line]==0)&&(diagonal1[i+line]==0)&&(diagonal2[7+i-line]==0)) // attention
{
chessBoard[i][line]=1;
latitude[i]=1;
longitude[line]=1;
diagonal1[i+line]=1;
diagonal2[7+i-line]=1;
queens--;
if (queens>0)
Check_Queen(line+1); // 查找下一列
else
{
cASe++;
cout << "No. " << cASe << endl;
for (j=0; j<8; j++)
{
for (k=0; k<8; k++)
cout << chessBoard[j][k] << ' ';
// if it's necessary to use printf?
cout << endl;
}
}
// 回溯
chessBoard[i][line]=0;
latitude[i]=0;
longitude[line]=0;
diagonal1[i+line]=0;
diagonal2[7+i-line]=0;
queens++;
}
}
}
//2699 自除整数
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
#include<iostream>
using namespace std;
int main()
{
int a,b;
cin>>a;
for(b=10;b<=a;b++)
{
if(b%(b/10+b%10)==0)
cout<<b<<endl;
}
return 0;
}
//POJ2700
#include <iostream>
#include <cstring>
using namespace std;
int main()
{
char str[40],ch1,ch2;
int n=0,i=0,j=0,length1=0;
cin >> n;
for (i=0; i<n; i++)
{
cin >> str >> ch1 >> ch2;
length1 = strlen(str);
for (j=0; j<length1; j++)
if (str[j]==ch1)
str[j] = ch2;
cout << str << endl;
}
return 0;
}
POJ2701
#include<iostream>
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
using namespace std;
int main()
{
int i,n,b,c;
cin>>n; b=0; c=1;
for(i=1;i<=n;i++)
{ c=0;
if((i%7!=0)&&((i%10!=7)&&((69<i)&&(i<80))==0)==1)
{
c=i*i;
}
b=b+c;
}
cout<<b<<endl;
return 0;
}
//2702
//address computerroom
//time Jan.2,2010
//function 密码翻译
//WANGYU
#include<iostream>
#include<cstring>
using namespace std;
int main()
{
char str[100][100];
char nnn[3];
int n,i,j;
cin.getline(nnn,3);
n=atoi(nnn);
for (i=0; i<n; i++)
cin.getline(str[i],100);
for (i=0; i<n; i++)
{
for (j=0; j<strlen(str[i]); j++)
{
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
if
(((str[i][j]>='a')&&(str[i][j]<'z'))||((str[i][j]>='A')&&(str[i][j]<'Z')))
str[i][j]++;
else if (str[i][j]=='Z') str[i][j]='A';
else if (str[i][j]=='z') str[i][j]='a';
}
cout << str[i] << endl;
}
return 0;
}
Generated by Foxit PDF Creator ? Foxit Software
http://www.foxitsoftware.com For evaluation only.
// POJ2703
#include<iostream>
using namespace std;
int main()
{
unsigned int i,n,s;
float a,b;
cin>>n;
for(i=1;i<=n;i++)
{
cin>>s;
a=s/1.2;
b=s/3.0+50;
if(a<=b)
{
if(a==b)
{
cout<<"All"<<endl;
}
else
{
cout<<"Walk"<<endl;
}
}
else
{
cout<<"Bike"<<endl;
}
}
return 0;
}
//POJ2708
//address computerroom
//time Oct.9,2009 night
//function 平衡饮食
#include<iostream>
using namespace std;
int main()
{
int rice,wheat,vegetables,bean,egg,lean,beef,fish,oil,fruits;
double protein,fat,carbon,hot;
cin >> rice >> wheat >> vegetables >> bean >> egg >> lean >> beef >> fish >> oil >>
fruits;
protein = rice/100.0*7.5 + wheat/100.0*10 + vegetables*0.015 + bean*0.35 + egg*5 +
lean*0.165 + beef*0.177 + fish*0.149 + fruits*0.0085;
fat = rice*0.0075 + wheat*0.0125 + vegetables*0.0019 + bean*0.18 + egg*5 + lean*0.288
+ beef*0.2033 + fish*0.008 + oil + fruits*0.005;
carbon = rice*0.78 + wheat*0.75 + vegetables*0.0428 + bean*0.42 + egg*0.6 + lean*0.0105
+ beef*0.0406 + fish*0.0093 + fruits*0.08;
// 在这里将质量全部变为能量
protein *= 4.1;
fat *= 9.3;
carbon *= 4.1;
hot = protein + fat + carbon;
if
((hot==0)||(protein/hot<0.14)||(protein/hot>0.16)||(fat/hot<0.3)||(fat/hot>0.35)||(carbon/ho
t<0.49)||(carbon/hot>0.56))
cout << "no\n";
else
cout << "yes\n";
return 0;
}
// POJ2709
#include<iostream>
#include<iomanip>
using namespace std;
int main()
{
double n,i,k; double a,b;
cin>>n; b=0;
for(i=n;i>=1;i=i-1)
{ a=1;
for(k=i;k>=1;k=k-1)
{
a=a*k;
}
a=1/a;
b=b+a;
}
b=b+1;
cout<<fixed<<setprecision(10)<<b<<endl;
return 0;
}
/**********************
author KINGRAIN@EECS_PKU
time Dec.22,2009
address computer room 184
poj2710
数制转换
***********************/
#include<iostream>
#include<cstring>
#include<cmath>
using namespace std;
int main()
{
short int a,b,i,j,k; char array1[20], array2[20]; long int long_integer=0;
cin >> a >> array1 >> b;
for (i=strlen(array1)-1,j=0; i>=0; i--,j++) // 按照权
位展开变成十进制整数
{
if ( array1[i] < 58)
{
long_integer += (array1[i]-48) * (int)pow (a*1.0,j);
}
if ( array1[i] > 96)
{
long_integer += (array1[i]-87) * (int)pow (a*1.0,j);
}
else if ( array1[i] > 64)
{
long_integer += (array1[i]-55) * (int)pow (a*1.0,j);
}
}
strcpy(array1,"\0"); i=0;
do
{
if ((long_integer%b)>=10)
array1[i]=(long_integer%b)+55;
else
array1[i]=(long_integer%b)+48;
i++;
long_integer /= b;
} while (long_integer!=0);
array1[i]='\0';
for (k=0; k<i; k++)
{
array2[k] = array1[i-k-1];
}
array2[k]='\0';
cout << array2 << endl;
return 0;
}
/* 2712
功能 求细菌数目
作者 KINGRAIN@EECS_PKU
time Oct.15,2009
address computer room
*/
#include<iostream>
#include<cmath>
using namespace std;
int main()
{
int a,b,c,d,e,f,g; short int n,i; long double p; long int q;
cin>>n;
for(i=1;i<=n;i++)
{ g=0;
cin>>a>>b>>e>>c>>d;
if(b<=d)
{ if(a=c) g=d-b+1;
else
{
for(f=a;f<c;f++)
{
if((f==1)||(f==3)||(f==5)||(f==7)||(f==8)||(f==10))
{ g=g+31;} //1 3 5 7 8 10 月有31 天 不会为
12 月
if(f==2)
{ g=g+28;}
if((f==4)||(f==6)||(f==9)||(f==11))
{ g=g+30;}
}
g=g+d-b+1;
}
}
else
{
for(f=a;f<c;f++)
{
if((f==1)||(f==3)||(f==5)||(f==7)||(f==8)||(f==10))
{ g=g+31;}
if(f==2)
{ g=g+28;}
if((f==4)||(f==6)||(f==9)||(f==11))
{ g=g+30;}
}
g=g+d-b+1;
}
p=pow(2.0,(g-1)); //g 之前数错了 依次改太麻烦了 现在统一改
q=int(p);
q=q*e;
cout<<q<<endl;
}
return 0; //程序很繁琐 应该会有更简洁的办法 也可以定义更少的变量
}
/**********************
author KINGRAIN@EECS_PKU
time Feb.10,2010
home
poj2713
肿瘤面积
***********************/
#include<iostream>
using namespace std;
int main()
{
int n,i,j,s[1500][1500],inside=0,total=0;
cin >> n;
for (i=0; i<n; i++)
for (j=0; j<n; j++)
cin >> s[i][j];
for (i=0; i<n; i++) // 横向扫描
for (j=0; j<n; j++)
{
if ((s[i][j]==0)&&(s[i][j+1]==0)) // 水平边
do
{
j++;
} while ((j<n)&&(s[i][j]==0));
else if ((s[i][j]==0)&&(s[i][j+1]!=0)) // 竖直边
{
do
{
j++;
if (s[i][j]>0)
inside++;
} while ((j<n)&&(s[i][j]!=0));
}
}
cout << inside << endl;
return 0;
}
// POJ2714
#include<iostream>
#include<iomanip>
using namespace std;
int main()
{
double n,i; double a,b;
cin>>n; b=0;
for(i=n;i>=1;i=i-1)
{ cin>>a;
b=a+b;
}
b=b/n;
cout<<fixed<<setprecision(2)<<b<<endl;
return 0;
}
//POJ2715
#include<iostream>
using namespace std;
int main()
{
struct STU
{
char name[50];
short int final;
short int others;
unsigned long int amount;
char ganbu;
char west;
short int theory;
}student[150];
int n,k; unsigned long int total=0, money=0;
cin >> n;
if ((n>0)&&(n<=100))
{
for (int i=0; i<n; i++)
{
cin >> student[i].name >> student[i].final >> student[i].others >>
student[i].ganbu;
cin >> student[i].west ; cin >> student[i].theory;
student[i].amount=0;
}
for (int j=0; j<n; j++)
{
if ((student[j].final>80)&&(student[j].theory>0))
{
student[j].amount += 8000;
total += 8000;
}
if ((student[j].final>85)&&(student[j].others>80))
{
student[j].amount += 4000;
total += 4000;
}
if ((student[j].final>90))
{
student[j].amount += 2000;
total += 2000;
}
if
((student[j].final>85)&&((student[j].west=='Y')||(student[j].west=='y')))
{
student[j].amount += 1000;
total += 1000;
}
if
((student[j].others>80)&&((student[j].ganbu=='Y')||(student[j].ganbu=='y')))
{
student[j].amount += 850;
total += 850;
}
}
for (k=0; k<n; k++)
{
if (money<=student[k].amount)
money = student[k].amount;
}
if (money!=0)
{
for (k=0; k<n; k++)
{
if (money==student[k].amount)
{
cout << student[k].name << endl;
break;
}
}
cout << money << '\n' << total << '\n';
}
}
return 0;
}
//POJ2718
#include<iostream>
using namespace std;
int main()
{
unsigned int a;
cin>>a;
if(a%2==0)
{
cout<<"YES"<<endl;
}
else
{
if(a==7)
{
cout<<"YES"<<endl;
}
else
{
cout<<"NO"<<endl;
}
}
return 0;
}
/*2719
功能 淘淘摘苹果
作者 KINGRAIN@EECS_PKU
time Oct.10,2009
address computer room
*/
#include<iostream>
using namespace std;
int main()
{
int a[9],m,n=0,i;
for(i=0;i<=9;i++)
{
cin>>a[i];
}
cin>>m;
for(i=0;i<=9;i++)
{
if(m+30>=a[i])
n++;
}
cout<<n<<endl;
return 0;
}
//POJ2720
#include<iostream>
using namespace std;
int main()
{
double n,h,r;
const double pi=3.14159;
double v;
cin>>h>>r;
v=h/10*3.14159*(r/10)*(r/10);
n=0;
do
{
n=n+1;
}
while(n*v<=20);
cout<<n<<endl;
return 0;
}
/*********************************************************
POJ2722
功能 学分绩点
作者 KINGRAIN@EECS_PKU
time Feb.9,2010
address home
*********************************************************/
#include<iostream>
#include<iomanip>
using namespace std;
int main()
{
int n,i,credit[15],score[15],sum=0; double GPA=0;
cin >> n;
for (i=0; i<n; i++)
{
cin >> credit[i];
sum += credit[i];
}
for (i=0; i<n; i++)
cin >> score[i];
for (i=0; i<n; i++)
{
if (score[i]>=90)
GPA += (4.0*credit[i]);
else if (score[i]>=85)
GPA += (3.7*credit[i]);
else if (score[i]>=82)
GPA += (3.3*credit[i]);
else if (score[i]>=78)
GPA += (3.0*credit[i]);
else if (score[i]>=75)
GPA += (2.7*credit[i]);
else if (score[i]>=72)
GPA += (2.3*credit[i]);
else if (score[i]>=68)
GPA += (2.0*credit[i]);
else if (score[i]>=64)
GPA += (1.5*credit[i]);
else if (score[i]>=60)
GPA += (1.0*credit[i]);
else
GPA += 0;
}
cout << fixed << setprecision(2) << GPA/sum*1.0 << endl;
return 0;
}
//2723
//time Oct.9,2009
//address computerroom
//function 求不吉利日期
#include<iostream>
using namespace std;
int main()
{
int w,a;
cin>>w;
if(12%7==(5-w)||12%7==(12-w))
cout<<1<<endl;
if(43%7==(5-w)||43%7==(12-w))
cout<<2<<endl;
if((43+28)%7==(5-w)||(43+28)%7==(12-w)) //太乱太繁琐 需要人力计算，应该规整一下
cout<<3<<endl;
a=43+28; //规整
a=a+31; //规整
if(a%7==(5-w)||a%7==(12-w))
cout<<4<<endl;
a += 30;
if(a%7==(5-w)||a%7==(12-w))
cout<<5<<endl;
a += 31;
if(a%7==(5-w)||a%7==(12-w))
cout<<6<<endl;
a += 30;
if(a%7==(5-w)||a%7==(12-w))
cout<<7<<endl;
a += 31;
if(a%7==(5-w)||a%7==(12-w))
cout<<8<<endl;
a += 31;
if(a%7==(5-w)||a%7==(12-w))
cout<<9<<endl;
a += 30;
if(a%7==(5-w)||a%7==(12-w))
cout<<10<<endl;
a += 31;
if(a%7==(5-w)||a%7==(12-w))
cout<<11<<endl;
a += 30;
if(a%7==(5-w)||a%7==(12-w))
cout<<12<<endl;
return 0;
}
//POJ2728
#include<iostream>
using namespace std;
int main()
{
cout<<"Welcome to C++!"<<endl;
return 0;
}
//POJ2729
#include<iostream>
using namespace std;
int main()
{
int a,n,i;
cin>>n; a=1;
for(i=1;i<=n;i++)
{
a=a*i;
}
cout<<a<<endl;
return 0;
}
//POJ2730
#include<iostream>
#include<iomanip>
using namespace std;
int main()
{
unsigned long double a,i,n;
cin>>n; a=1;
for(i=1;i<=n;i++)
{
a=a*i;
}
cout<<fixed<<setprecision(0)<<a<<endl;
return 0;
}
/**********************
author KINGRAIN@EECS_PKU
time Aug.5,2010
home
poj2731
求10000 以内n 的阶乘
***********************/
#include <iostream>
#include <time.h>
#include <set>
using namespace std;
const int MAX = 50000; // should be 40000
unsigned int result[MAX]={0};
int wmain()
{
int n=1, i, j, k, length=1;
cin >> n;
for (i=1, result[0]=1; i<=n; i++)
{
for (j=0; j<length; j++)
result[j] *= i;
if (i<=55) {
if (i%5==0) {
for (k=0; k!=length-1; k++)
if (result[k]>9)
{
result[k+1] += (result[k]/10);
result[k] %= 10;
}
while (result[k]>9) // {
result[k+1] += (result[k]/10);
result[k] %= 10;
k++;
length++;
}
}
}
else if (i<=750)
{
if (i%3==0) {
for (k=0; k!=length-1; k++)
if (result[k]>9)
{
result[k+1] += (result[k]/10);
result[k] %= 10;
}
while (result[k]>9) // {
result[k+1] += (result[k]/10);
result[k] %= 10;
k++;
length++;
}
}
}
else
{
if (i%2==0) {
for (k=0; k!=length-1; k++)
if (result[k]>9)
{
result[k+1] += (result[k]/10);
result[k] %= 10;
}
while (result[k]>9) // {
result[k+1] += (result[k]/10);
result[k] %= 10;
k++;
length++;
}
}
}
}
for (k=0; k!=length-1; k++)
if (result[k]>9)
{
result[k+1] += (result[k]/10);
result[k] %= 10;
}
while (result[k]>9) // 最高位
进位
{
result[k+1] += (result[k]/10);
result[k] %= 10;
k++;
length++;
}
for (length=MAX; result[length-1]==0; length--); // 准备开始打印
int line = length/50 + 1;
for (i=(line)*50-1; i>=0; i--)
{
cout << result[i];
if (i%50==0)
cout << '\n';
}
return 0;
}
//POJ2733
//判断闰年
#include<iostream>
#include<cmath>
using namespace std;
int main()
{
unsigned int a;
cin>>a;
if(a%100==0)
{
if(a%400==0)
{
cout<<"Y"<<endl;
}
else
{
cout<<"N"<<endl;
}
}
else
{
if(a%4==0)
{
cout<<"Y"<<endl;
}
else
{
cout<<"N"<<endl;
}
}
return 0;
}
/* 2734
功能 十进制到八进制
作者 KINGRAIN@EECS_PKU
time Oct.17,2009
address computer room
*/
#include<iostream>
using namespace std;
int main()
{
int a;
cin>>a;
if(a>=0) cout<<oct<<a<<endl;
return 0;
}
/*2735
八进制变十进制
*/
#include<iostream>
#include<iomanip>
using namespace std;
int main()
{
int a,b;
cin>>oct>>a;
b=a;
cout<<b<<endl;
return 0;
}
/**********************
POJ2736
author KINGRAIN@EECS_PKU
time Nov.27,2009
address computer room 160
***********************/
#include<iostream>
#include<cstring>
using namespace std;
int main()
{
int i,j,n,k,length1,length2; char str1[120],str2[120];
cin >> n;
for (k=1; k<=n; k++)
{
cin.get(); // 吃掉前一个回车 形成数据间的空
行
cin.getline(str1,120); // 输入被减数
cin.getline(str2,120); // 输入减数
length1 = strlen(str1); // 记录长度
length2 = strlen(str2);
for (i=length2-1,j=length1-1; i>=0; i--,j--)
{
if (str1[j]>=str2[i])
str1[j] = str1[j] - str2[i] + 48; // +48
是为了由数字变为 ASCII 码
else
{
str1[j] = str1[j] - str2[i] + 10 + 48;
str1[j-1]--; // 借一位
}
}
str1[length1] = '\0'; // 变为字符串，直接输出
cout << str1 << endl;
}
return 0;
}
/**********************
author KINGRAIN@EECS_PKU
time April 4,2010
computerroom
poj2737
大整数除法
***********************/
#include <iostream>
#include <cstring>
using namespace std;
const int LENGTH = 110;
char num1[LENGTH]={0},num2[LENGTH]={0},temp[LENGTH]={0},sum[LENGTH]={0};
int Divide(int);
int length1=0,length2=0;
int main()
{
int n=0,i=0,t=0,j=0,delta=0;
cin >> t;
for (i=0; i<t; i++)
{
memset(sum,0,sizeof(sum));
cin >> num1 >> num2;
length1 = strlen(num1);
length2 = strlen(num2);
_strrev(num2), _strrev(num1); // 将两个数字都逆
序
delta = length1 - length2;
if (delta<0)
{
printf("0\n");
continue;
}
for (j=0; delta>=0;j++)
{
sum[j] = '0'+ Divide(delta--);
}
sum[j] = 0;
char *ptr=sum;
for (j=0; ptr[j]=='0'; j++); // 空循环去除前导零
cout << ptr+j << endl;
}
return 0;
}
int Divide(int n) // 用字符做减法与用整形数组做减法那个更好？
{
int i=0,N=0;
memset(temp,0,sizeof(temp));
for (i=length2+n-1; i>=n; i--)
temp[i] = num2[i-n];
for (; i>=0; i--)
temp[i] = '0';
while ((length1>=length2+n))
{
if (length1==length2+n)
{
char N1[LENGTH],N2[LENGTH];
strcpy(N1,num1), _strrev(N1), strcpy(N2,temp),
_strrev(N2);
if (strcmp(N1,N2)<0)
return N;
}
for (i=0; i<length2+n; i++)
{
num1[i] = num1[i] - temp[i] + '0';
if (num1[i]<'0')
{
num1[i] += 10;
num1[i+1]--;
}
}
N++;
for (i=length1-1; ((num1[i]=='0')&&(i>=0)); i--,length1--);
num1[i+1] = 0;
}
return N;
}
/**********************
author KINGRAIN@EECS_PKU
time Mar.20,2010
dorm
poj2738
浮点数加法
***********************/
#include <iostream>
#include <cstring>
using namespace std;
int main()
{
char add1[200]={0}, add2[200]={0}; // add1 & add2 分别是两个加数
char integer1[100]={0},integer2[100]={0};
int
n=0,i=0,j=0,k=0,l=0,m=0,length1=0,length2=0,pointpos1=0,pointpos2=0; //
pointpos 记录小数点的位置 length 记录加数的长度
int inresult[100]={0},deresult[100]={0}; // integer 记录整数部分
decimal 记录小数部分
cin >> n;
for (i=0; i<n; i++)
{
cin >> add1 >> add2;
memset(inresult,0,sizeof(inresult));
memset(deresult,0,sizeof(deresult));
length1 = strlen(add1);
length2 = strlen(add2);
for (j=0; add1[j]!='.'; j++); // 空循环 确定小数点位置
pointpos1 = j;
for (j=0; add2[j]!='.'; j++); // 空循环 确定小数点位置
pointpos2 = j;
for (m=1,j=pointpos1+1,k=pointpos2+1; add1[j]||add2[k];
j++,k++,m++) // 小数部分相加
{
if (j<length1)
deresult[m] += add1[j]-'0';
if (k<length2)
deresult[m] += add2[k]-'0';
}
// 此时 m-1 就是小数的位数
for (j=m-1; j>0; j--)
if (deresult[j]>9)
{
deresult[j-1]++;
deresult[j] -= 10;
}
for (l=0,j=pointpos1-1,k=pointpos2-1; j>=0||k>=0; j--,k--,l++)
{
if (j>=0)
inresult[l] += add1[j]-'0';
if (k>=0)
inresult[l] += add2[k]-'0';
}
if (deresult[0]==1) // 从小数到整数的进位
inresult[0]++;
for (j=0; j<l; j++)
if (inresult[j]>9)
{
inresult[j+1] += 1;
inresult[j] -= 10;
}
while (inresult[j+1])
j++; // 保证j 处于整数的最高位
l = j; // l 记载了整数的位数 以后不变
for (j=l-1; j>=0; j--)
printf("%d",inresult[j]);
printf(".");
for(j=m; deresult[j]==0; j--); // 空循环 去掉最后的0
m=j;
for (j=1; j<=m; j++)
printf("%d",deresult[j]);
printf("\n");
}
return 0;
}
/**********************
author KINGRAIN@EECS_PKU
time May 17,2010
dorm
poj2739
计算对数
***********************/
#include <iostream>
#include <cstring>
#include <memory>
using namespace std;
const int MAX=120;
char A[MAX]={0},B[MAX]={0};
int a[MAX]={0},b[MAX]={0},result[MAX]={0},length=0,length1=0,length2=0;
bool COMPARE(int [],int[]);
void Caculate();
int main()
{
int n=0,i=0,j=0,k=0,m=0;
cin >> n;
for (i=0; i<n; i++)
{
cin >> A >> B;
length1 = strlen(A);
for (k=length1-1; k>=0; k--)
a[length1-k-1] = A[k] - '0';
length2 = strlen(B);
for (k=length2-1; k>=0; k--)
b[length2-k-1] = B[k] - '0';
length = length1;
memcpy(result,a,sizeof(a));
for (j=0; j<21; j++)
{
if (COMPARE(result,b))
{
cout << j << endl;
break;
}
Caculate();
}
memset(a,0,MAX*sizeof(int));
memset(b,0,MAX*sizeof(int));
memset(result,0,MAX*sizeof(int));
}
return 0;
}
void Caculate()
{
int temp[MAX]={0};
for (int i=0; i<length; i++)
for (int j=0; j<length1; j++)
temp[i+j] += result[i] * a[j];
int i=0;
for (; i<length; i++)
{
if (temp[i]>10)
{
temp[i+1] += temp[i]/10;
temp[i] %= 10;
}
}
while (temp[i]>0)
{
if (temp[i]>10)
{
temp[i+1] += temp[i]/10;
temp[i] %= 10;
}
i++;
}
for (i=MAX-1; temp[i]==0; i--);
length = i+1;
memcpy(result,temp,sizeof(result));
}
bool COMPARE(int r[],int b[])
{
for (int i=MAX-1; i>=0; i--)
if (r[i]>b[i])
return 1;
else if (r[i]<b[i])
return 0;
}
/**********************
author KINGRAIN@EECS_PKU
time April 17,2010
dorm
poj2746
约瑟夫问题 猴子选大王
***********************/
#include <iostream>
using namespace std;
struct MONKEY
{
int num;
MONKEY * next;
};
int main()
{
int n,m;
while (cin >> n >> m)
{
if (n==0)
break;
if (m==1) // 针对 m==1 直接
可以知道答案 是n
{
printf("%d\n",n);
continue;
}
MONKEY *head=0,*current=0;
for (int i=0; i<n; i++) // 建立循环链表
{
if (head==0)
{
current = new MONKEY;
current->num = 1;
head = current;
current->next = current; // 防止自己循环但
实际上 测试数据应该不会有n==1
}
else
{
current->next = new MONKEY;
current = current->next;
current->num = i+1;
current->next = head; // 成环
}
}
current = head;
MONKEY *temp=0;
int i=1;
while (current->next!=current)
{
for (int i=1; i!=m-1; i++) // 报数，
报到m-1 时停止
current = current->next;
temp = current->next;
/* 记录下要出列的那个节点*/
current->next = current->next->next; // 不让环
断开，当前节点与要出列节点的下一个节点相连
current = current->next; // 当前指
针向后移动
delete temp;
}
printf("%d\n",current->num);
}
return 0;
}
//POJ2747
#include <iostream>
#include <cstring>
using namespace std;
int main()
{
int i=0,j=0,k=0,n=0,l=0,max=0,t=0;
cin >> t;
for (i=0; i<t; i++)
{
cin >> n;
max = 0;
for (j=0; j<=n; j++)
for (k=0; k<=n; k++)
{
if ((j+k)%2==1)
continue;
for (l=0; l<=n; l++)
{
if ((l+k)%3!=0)
continue;
if (((l+j+k)%5==0)&&((l+j+k)>max))
max = l+j+k;
}
}
cout << max << endl;
}
return 0;
}
//POJ2748
#include <iostream>
#include <cstring>
using namespace std;
char string_string[8]={0},temp[9]={0};
int length=0,k=0,n=0;
void Out_put(int order,int num);
int Mycompare(const void *elem1,const void *elem2);
int main()
{
int i=0,j=0;
cin >> string_string;
n = strlen(string_string);
qsort(string_string,n,sizeof(string_string[0]),Mycompare);
strcpy(temp,string_string);
Out_put(0,0);
return 0;
}
int Mycompare(const void *elem1,const void *elem2)
{
char *p1=0,*p2=0;
p1 = (char *)elem1;
p2 = (char *)elem2;
return (p1-p2);
}
void Out_put(int order,int num)
{
bool flag = 0;
for (int i=0; i<n; i++,flag=0)
{
temp[num] = string_string[i];
for (int j=0; j<num; j++)
if (temp[j]==temp[num])
{
flag = 1;
break;
}
if (flag==1)
continue;
else
{
if (num==n-1)
cout << temp << endl;
else
Out_put(0,num+1);
}
}
}
/**********************
分解因数
poj2749
author KINGRAIN@EECS_PKU
time Dec.3,2009
address computer room 183
***********************/
#include<iostream>
using namespace std;
void TRY(int, int); // void try() try 为什么会用蓝色显示？？
unsigned short int num=1; // num 为计数器 记录一共有多少种方法
整数本身与1 相乘就是一种 所以初始值为1
int main()
{
unsigned short int n,i; int INTEGER;
cin >> n;
for (i=1; i<=n; i++)
{
cin >> INTEGER;
TRY(2,INTEGER); // 从2 开始取值
cout << num << endl;
num = 1;
}
return 0;
}
void TRY(int factor,int INTEGER)
{
for (; factor*factor<=INTEGER; factor++)
{
// 如果是它的因数，那么就试一下 与它“配对”的因数 看配对因
数能否被分解。 同时这也是程序的出口，如果一直不满足该条件，那么就直接退出
if (INTEGER%factor == 0)
{
num++; // 已经找到一种方法，方
案数加一
TRY(factor,INTEGER/factor); // 递归
}
}
}
/**********************
author KINGRAIN@EECS_PKU
time Feb.8,2010
home
poj2750
鸡兔同笼问题
***********************/
#include<iostream>
#include<cmath>
using namespace std;
int main()
{
int n,i,a,results[200][2]={0};
cin >> n;
for (i=0; i<n; i++)
{
cin >> a;
if (a%2==1)
results[i][0]=results[i][1]=0;
else if (a%4==0)
{
results[i][0] = a/4;
results[i][1] = a/2;
}
else
{
results[i][0] = a/4+1;
results[i][1] = a/2;
}
}
for (i=0; i<n; i++)
cout << results[i][0] << ' ' << results[i][1] << endl;
return 0;
}
/**********************
author KINGRAIN@EECS_PKU
time Mar.22,2010
classroom
poj2752
字符串数组排序问题
***********************/
#include <iostream>
#include <cstring>
using namespace std;
int MycompareInc(const void * elem1,const void* elem2);
int MycompareDec(const void * elem1,const void* elem2);
int MycompareNcinc(const void * elem1,const void* elem2);
int MycompareNcdec(const void * elem1,const void* elem2);
int main()
{
//自然顺序（inc）、自然逆序（dec）、忽略大小写顺序（ncinc）、忽略大小写
逆序（ncdec）
char str[300][200]={0},kind[10];
int n=0,i=0;
cin >> kind;
cin >> n;
cin.getline(str[0],3); // 吃掉cin 回车
for (i=0; i<n; i++)
cin.getline(str[i],200);
if (strcmp(kind,"inc")==0)
qsort(str,n,sizeof(str[0]),MycompareInc);
else if (strcmp(kind,"dec")==0)
qsort(str,n,sizeof(str[0]),MycompareDec);
else if (strcmp(kind,"ncinc")==0)
qsort(str,n,sizeof(str[0]),MycompareNcinc);
else if (strcmp(kind,"ncdec")==0)
qsort(str,n,sizeof(str[0]),MycompareNcdec);
for (i=0; i<n; i++)
printf("%s\n",str[i]);
return 0;
}
int MycompareInc(const void * elem1,const void* elem2)
{
char p1[200],p2[200];
int j=0,k=0,l=0;
strcpy(p1,(const char *)elem1);
strcpy(p2,(const char *)elem2);
l = strlen(p1);
for (j=0; p1[j]==' '; j++); // 空循环找前导空格
if (j>0)
for (k=0; k<l-j; k++)
p1[k] = p1[k+j];
l = strlen(p1);
for (j=l-1; p1[j]==' '; j--); // 空循环找后继空格
p1[j+1] = '\0';
l = strlen(p2);
for (j=0; p2[j]==' '; j++); // 空循环找前导空格
if (j>0)
for (k=0; k<l-j; k++)
p2[k] = p2[k+j];
l = strlen(p2);
for (j=l-1; p2[j]==' '; j--); // 空循环找后继空格
p2[j+1] = '\0';
return (strcmp(p1,p2));
}
int MycompareDec(const void * elem1,const void* elem2)
{
char p1[200],p2[200];
int j=0,k=0,l=0;
strcpy(p1,(const char *)elem1);
strcpy(p2,(const char *)elem2);
l = strlen(p1);
for (j=0; p1[j]==' '; j++); // 空循环找前导空格
if (j>0)
for (k=0; k<l-j; k++)
p1[k] = p1[k+j];
l = strlen(p1);
for (j=l-1; p1[j]==' '; j--); // 空循环找后继空格
p1[j+1] = '\0';
l = strlen(p2);
for (j=0; p2[j]==' '; j++); // 空循环找前导空格
if (j>0)
for (k=0; k<l-j; k++)
p2[k] = p2[k+j];
l = strlen(p2);
for (j=l-1; p2[j]==' '; j--); // 空循环找后继空格
p2[j+1] = '\0';
return strcmp(p2,p1);
}
int MycompareNcinc(const void * elem1,const void* elem2)
{
char p1[200],p2[200];
int j=0,k=0,l=0;
strcpy(p1,(const char *)elem1);
strcpy(p2,(const char *)elem2);
l = strlen(p1);
for (j=0; p1[j]==' '; j++); // 空循环找前导空格
if (j>0)
for (k=0; k<l-j; k++)
p1[k] = p1[k+j];
l = strlen(p1);
for (j=l-1; p1[j]==' '; j--); // 空循环找后继空格
p1[j+1] = '\0';
l = strlen(p2);
for (j=0; p2[j]==' '; j++); // 空循环找前导空格
if (j>0)
for (k=0; k<l-j; k++)
p2[k] = p2[k+j];
l = strlen(p2);
for (j=l-1; p2[j]==' '; j--); // 空循环找后继空格
p2[j+1] = '\0';
return (_stricmp(p1,p2));
}
int MycompareNcdec(const void * elem1,const void* elem2)
{
char p1[200],p2[200];
int j=0,k=0,l=0;
strcpy(p1,(const char *)elem1);
strcpy(p2,(const char *)elem2);
l = strlen(p1);
for (j=0; p1[j]==' '; j++); // 空循环找前导空格
if (j>0)
for (k=0; k<l-j; k++)
p1[k] = p1[k+j];
l = strlen(p1);
for (j=l-1; p1[j]==' '; j--); // 空循环找后继空格
p1[j+1] = '\0';
l = strlen(p2);
for (j=0; p2[j]==' '; j++); // 空循环找前导空格
if (j>0)
for (k=0; k<l-j; k++)
p2[k] = p2[k+j];
l = strlen(p2);
for (j=l-1; p2[j]==' '; j--); // 空循环找后继空格
p2[j+1] = '\0';
int n = _stricmp(p1,p2);
return -n;
}
//POJ2753
#include<iostream>
using namespace std;
int main()
{
long int a,b,c,d,m,n,i;
cin>>n; //输入n 组数据
for(i=1;i<=n;i++)
{
cin>>a; //要求第a 个数大小
b=1;c=1;
for(m=3;m<=a;m++)
{
d=c+b;
b=c; c=d; //c=a/m
}
cout<<c<<endl;
}
return 0;
}
/**********************
author KINGRAIN@EECS_PKU
time April 3,2010
dorm
poj2754
八皇后问题 输出字符串
***********************/
#include <iostream>
using namespace std;
void Set_position(int n);
bool latitude[8]={0},longitude[8]={0},diag[15]={0},antiDiag[15]={0};
int queen[8]={0},order=0;
char solution[93][9]={0};
int main()
{
Set_position(0);
int n=0,i=0,t=0;
cin >> n;
for (i=0; i<n; i++)
{
cin >> t;
cout << solution[t-1] << endl;
}
return 0;
}
void Set_position(int n) // 横向扫描n 是行数
{
for (int i=0; i<8; i++)
{
if ((longitude[i]==0)&&(diag[7+i-n]==0)&&(antiDiag[i+n]==0))
{
longitude[i] = 1;
diag[7+i-n] = 1;
antiDiag[i+n] = 1;
solution[order][n] = i+1+'0'; // 0+1
if (n==7)
{
solution[order][8] = '\0';
strcpy(solution[order+1],solution[order]);
order++;
}
else
Set_position(n+1);
longitude[i] = 0; // 回溯
diag[7+i-n] = 0;
antiDiag[i+n] = 0;
}
}
return ;
}
/**********************
author KINGRAIN@EECS_PKU
time May 21,2010
computer room187
poj2755
神奇口袋
***********************/
#include <iostream>
using namespace std;
int Find(int [],int,int);
int Mycompare(const void *,const void *);
int n=0;
int main()
{
int packet[30]={0},i=0,j=0,k=0;
cin >> n;
for (i=0; i<n; i++)
cin >> packet[i];
qsort(packet,n,sizeof(packet[0]),Mycompare);
for (i=0; i<n; i++)
k += Find(&packet[i],40-packet[i],i);
cout << k << endl;
return 0;
}
int Mycompare(const void *ele1,const void *ele2)
{
int *ptr1 = (int *)ele1;
int *ptr2 = (int *)ele2;
return (*ptr2-*ptr1);
}
int Find(int a[], int amount, int order)
{
if (amount<0)
return 0;
if (amount==0)
return 1;
if (order==n-1)
return 0;
return (Find(&a[1],amount-a[1],order+1)+Find(&a[1],amount,order+1));
}